{"task_id": "HumanEval/10", "completion": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    if not string:\n        return ''\n    if is_palindrome(string):\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string + string[::-1]\n\n\nif __name__ == \"__main__\":\n    print(make_palindrome(\"cat\"))\n    print(make_palindrome(\"cata\"))\n    print(make_palindrome(\"\"))\n    print(make_palindrome(\"a\"))\n    print(make_palindrome(\"aa\"))\n    print(make_palindrome(\"aaa\"))\n    print(make_palindrome(\"aaaa\"))\n    print(make_palindrome(\"aaaaa\"))\n    print(make_palindrome(\"aaaaaa\"))\n    print(make_palindrome(\"aaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaa\"))\n    print(makemain__(\"aaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_palindrome(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\n    print(make_pal"}
{"task_id": "HumanEval/114", "completion": "\ndef minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        min_sum = min(min_sum, current_sum)\n        current_sum = min(current_sum, 0)\n    return min_sum\n\n\nprint(minSubArraySum([2, 3, 4, 1, 2, 4]))  # 1\nprint(minSubArraySum([-1, -2, -3]))  # -6\nprint(minSubArraySum([1, 2, 3, 4, 5]))  # 1\nprint(minSubArraySum([-2, 1, -3, 4, -1, 2, 1, -5, 4]))  # -1\nprint(minSubArraySum([3, -2, 5, -4, 3, -2]))  # -2\nprint(minSubArraySum([1, 2, 3, 4, 5, 6, 7, 8, 9]))  # 1\nprint(minSubArraySum([-1, -2, -3, -4, -5, -6, -7, -8, -9]))  # -1\nprint(minSubArraySum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))  # 1\nprint(minSubArraySum([-10, -2, -3, -4, -5, -6, -7, -8, -9]))  # -2\nprint(minSubArraySum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))  # 1\nprint(minSubArraySum([-11, -2, -3, -4, -5, -6, -7, -8, -9, -10]))  # -2\nprint(minSubArraySum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]))  # 1\nprint(minSubArraySum([-12, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11]))  # -2\nprint(minSubArraySum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]))  # 1\nprint(minSubArraySum([-13, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12]))  # -2\nprint(minSubArraySum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]))  # 1\nprint(minSubArraySum([-14, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13]))  # -2\nprint(minSubArraySum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]))  # 1\nprint(minSubArraySum([-15, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14]))  # -2\nprint(minSubArraySum([1, 2, 3, 4, 5, 6, "}
{"task_id": "HumanEval/23", "completion": "\n\ndef strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    if string == '':\n        return 0\n    else:\n        return 1 + strlen(string[1:])\n\n\ndef strrev(string: str) -> str:\n    \"\"\" Return reversed string\n    >>> strrev('')\n    ''\n    >>> strrev('abc')\n    'cba'\n    \"\"\"\n    if string == '':\n        return ''\n    else:\n        return string[-1] + strrev(string[:-1])\n\n\ndef strsub(string: str, sub: str) -> int:\n    \"\"\" Return number of occurrences of sub in string\n    >>> strsub('', '')\n    1\n    >>> strsub('abc', '')\n    1\n    >>> strsub('abc', 'a')\n    1\n    >>> strsub('abc', 'b')\n    1\n    >>> strsub('abc', 'c')\n    1\n    >>> strsub('abc', 'ab')\n    1\n    >>> strsub('abc', 'bc')\n    1\n    >>> strsub('abc', 'abc')\n    1\n    >>> strsub('abcabc', 'abc')\n    2\n    \"\"\"\n    if sub == string:\n        return 1\n    elif sub not in string:\n        return 0\n    else:\n        return 1 + strsub(string[string.index(sub) + 1:], sub)\n\n\ndef strcmp(string1: str, string2: str) -> int:\n    \"\"\" Compare two strings\n    >>> strcmp('', '')\n    0\n    >>> strcmp('a', 'a')\n    0\n    >>> strcmp('b', 'a')\n    1\n    >>> strcmp('a', 'b')\n    -1\n    \"\"\"\n    if string1 == string2:\n        return 0\n    elif string1 < string2:\n        return -1\n    else:\n        return 1#lab1/lab1.py\ndef hello_world():\n    return \"Hello, world!\"\n\ndef sum_of_numbers(a, b):\n    return a + b\n\ndef is_even(n):\n    return n % 2 == 0\n\ndef is_odd(n):\n    return n % 2 != 0\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef is_anagram(s1, s2):\n    return sorted(s1) == sorted(s2)\n\ndef is_subsequence(s1, s2):\n    i = j = 0\n    while i < len(s1) and j < len(s2):\n        if s1[i] == s2[j]:\n            i += 1\n        j += 1\n    return i == len(s1)\n\ndef is_substring(s1, s2):\n    return s1 in s2\n\ndef is_rotation(s1, s2):\n    return len(s1) == len(s2) and s1 in s2 + s2\n\ndef is_palindrome_permutation(s):\n    return sum(s.count(c) % 2 for c in set(s)) <= 1\n\ndef is_unique(s):\n    return len(set(s)) == len(s)\n\ndef is_permutation(s1, s2):\n    return sorted(s1) == sorted(s2)\n\ndef is_one_edit_away(s1, s2):\n    if len(s1) == len(s2):\n        return is_one_edit_replace(s1, s2)\n    elif len(s1) + 1 == len(s2):\n        return is_one_edit_insert(s1, s2)\n    elif len(s1) - 1 == len(s2):\n        return is_one_edit_insert(s2, s1)\n"}
{"task_id": "HumanEval/28", "completion": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n    return ''.join(strings)\n\ndef split(string: str) -> List[str]:\n    \"\"\" Split a string into a list of characters\n    >>> split('')\n    []\n    >>> split('abc')\n    ['a', 'b', 'c']\n    \"\"\"\n    return list(string)\n\ndef reverse(string: str) -:\n    \"\"\" Reverse a string\n    >>> reverse('')\n    ''\n    >>> reverse('abc')\n    'cba'\n    \"\"\"\n    return s[::-1]\n\ndef upper(string: str) -> str:\n    \"\"\" Convert a string to uppercase\n    >>> upper('')\n    ''\n    >>> upper('abc')\n    'ABC'\n    \"\"\"\n    return string.upper()\n\ndef lower(string: str) -> str:\n    \"\"\" Convert a string to lowercase\n    >>> lower('')\n    ''\n    >>> lower('ABC')\n    'abc'\n    \"\"\"\n    return string.lower()\n\ndef strip(string: str) -> str:\n    \"\"\" Remove leading and trailing whitespace from a string\n    >>> strip('')\n    ''\n    >>> strip('  abc  ')\n    'abc'\n    \"\"\"\n    return string.strip()\n\ndef replace(string: str, old: str, new: str) -> str:\n    \"\"\" Replace all occurrences of a substring in a string\n    >>> replace('', 'a', 'b')\n    ''\n    >>> replace('abcabc', 'a', 'b')\n    'bbcbc'\n    \"\"\"\n    return string.replace(old, new)\n\ndef startswith(string: str, prefix: str) -> bool:\n    \"\"\" Check if a string starts with a specific prefix\n    >>> startswing('', 'a')\n    False\n    >>> startswing('abc', 'a')\n    True\n    \"\"\"\n    return string.startswith(prefix)\n\ndef endswith(string: str, suffix: str) -> bool:\n    \"\"\" Check if a string ends with a specific suffix\n    >>> endswing('', 'a')\n    False\n    >>> endswing('abc', 'c')\n    True\n    \"\"\"\n    return string.endswith(suffix)\n\ndef find(string: str, substring: str) -> int:\n    \"\"\" Find the index of the first occurrence of a substring in a string\n    >>> find('', 'a')\n    -1\n    >>> find('abc', 'b')\n    1\n    \"\"\"\n    return string.find(substring)\n\ndef count(string: str, substring: str) -> int:\n    \"\"\" Count the number of occurrences of a substring in a string\n    >>> count('', 'a')\n    0\n    >>> count('abcabc', 'a')\n    2\n    \"\"\"\n    return string.count(substring)\n\ndef length(string: str) -> int:\n    \"\"\" Get the length of a string\n    >>> length('')\n    0\n    >>> length('abc')\n    3\n    \"\"\"\n    return len(string)\n\ndef is_empty(string: str) -> bool:\n    \"\"\" Check if a string is empty\n    >>> is_empty('')\n    True\n    >>> is_empty('abc')\n    False\n    \"\"\"\n    return len(string) == 0\n\ndef is_alpha(string: str) -> bool:\n    \"\"\" Check if a string contains only alphabetic characters\n    >>> is_alpha('')\n    True\n    >>> is_alpha('abc')\n    True\n    >>> is_alpha('abc123')\n    False\n    \"\"\"\n    return string.isalpha()\n\ndef is_digit(string: str) -> bool:\n    \"\"\" Check if a string contains only digits\n    >>> is_digit('')\n    True\n    >>> is_digit('123')\n    True\n    >>> is_digit('abc123')\n    False\n    \"\"\"\n    return string.isdigit()\n\ndef is_"}
{"task_id": "HumanEval/131", "completion": "\ndef digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n    product = 1\n    for digit in str(n):\n        if int(digit) % 2 != 0:\n            product *= int(digit)\n    return product if product != 1 else 0\n\n\nprint(digits(1))  # 1\nprint(digits(4))  # 0\nprint(digits(235))  # 15\nprint(digits(2468))  # 0\nprint(digits(13579))  # 15\nprint(digits(2846))  # 48\nprint(digits(8642))  # 14\nprint(digits(4286))  # 28\nprint(digits(6824))  # 32\nprint(digits(2684))  # 16\nprint(digits(8426))  # 48\nprint(digits(4682))  # 72\nprint(digits(2864))  # 32\nprint(digits(6428))  # 192\nprint(digits(8264))  # 32\nprint(digits(4826))  # 192\nprint(digits(2486))  # 32\nprint(digits(6248))  # 192\nprint(digits(8246))  # 192\nprint(digits(4268))  # 72\nprint(digits(6284))  # 192\nprint(digits(8426))  # 48\nprint(digits(4286))  # 28\nprint(digits(2846))  # 48\nprint(digits(6824))  # 32\nprint(digits(8642))  # 14\nprint(digits(4682))  # 72\nprint(digits(2684))  # 16\nprint(digits(6428))  # 192\nprint(digits(4826))  # 192\nprint(digits(2486))  # 32\nprint(digits(4268))  # 72\nprint(digits(2864))  # 32\nprint(digits(8264))  # 32\nprint(digits(6248))  # 192\nprint(digits(2864))  # 32\nprint(digits(8246))  # 192\nprint(digits(6284))  # 192\nprint(digits(4286))  # 28\nprint(digits(2468))  # 0\nprint(digits(8426))  # 48\nprint(digits(6824))  # 32\nprint(digits(4682))  # 72\nprint(digits(2684))  # 16\nprint(digits(8642))  # 14\nprint(digits(6428))  # 192\nprint(digits(4826))  # 192\nprint(digits(2846))  # 48\nprint(digits(8264))  # 32\nprint(digits(6248))  # 192\nprint(digits(4268))  # 72\nprint(digits(2486))  # 32\nprint(digits(8426))  # 48\nprint(digits(6824))  # 32\nprint(digits(4682))  # 72\nprint(digits(26"}
{"task_id": "HumanEval/88", "completion": "\ndef sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n    if len(array) == 0:\n        return []\n    elif len(array) == 1:\n        return [array[0]]\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            return sorted(array, reverse=True)\n        else:\n            return sorted(array)\n\n\nprint(sort_array([]))  # []\nprint(sortarray([5]))  # [5]\nprint(sort_array([2, 4, 3, 0, 1, 5]))  # [0, 1, 2, 3, 4, 5]\nprint(sort_array([2, 4, 3, 0, 1, 5, 6]))  # [6, 5, 4, 3, 2, 1, 0]\n\n# 1. 빈 배열이 주어지면 빈 배열을 반환합니다.\n# 2. 배열이 하나의 요소만 가지고 있으면 배열을 반환합니다.\n# 3. 배열이 두 개 이상의 요소를 가지고 있으면 첫 번째 요소와 마지막 요소의 합이 짝수이면 내림차순으로 정렬된 배열을 반환하고, 홀수이면 오름차순으로 정렬된 배열을 반환합니다.\n\n# 예시:\n# sort_array([]) => []\n# sort_array([5]) => [5]\n# sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n# sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\n# 주의:\n# 주어진 배열을 변경하지 마십시오.\n# 대신 정렬된 배열을 반환하십"}
{"task_id": "HumanEval/110", "completion": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    odd_lst1 = [num for num in lst1 if num % 2 != 0]\n    even_lst2 = [num for num in lst2 if num % 2 == 0]\n    if len(odd_lst1) <= len(even_lst2):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\nprint(exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\nprint(exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that the input lists will be non-empty.\n# It is assumed that"}
{"task_id": "HumanEval/34", "completion": "\n\ndef unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))\n\n\ndef unique_v2(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique_v2([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    result = []\n    for item in l:\n        if item not in result:\n            result.append(item)\n    return sorted(result)\n\n\ndef unique_v3(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique_v3([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    result = []\n    seen = set()\n    for item in l:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return sorted(result)\n\n\ndef unique_v4(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique_v4([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    result = []\n    seen = set()\n    for item in l:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return sorted(result)\n\n\ndef unique_v5(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique_v5([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    result = []\n    seen = set()\n    for item in l:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return sorted(result)\n\n\ndef unique_v6(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique_v6([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    result = []\n    seen = set()\n    for item in l:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return sorted(result)\n\n\ndef unique_v7(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique_v7([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    result = []\n    seen = set()\n    for item in l:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return sorted(result)\n\n\ndef unique_v8(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique_v8([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    result = []\n    seen = set()\n    for item in l:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return sorted(result)\n\n\ndef unique_v9(l: list):\n    \"\"\"Return sorted unique"}
{"task_id": "HumanEval/62", "completion": "\n\ndef derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    return [i * xs[i] for i in range(1, len(xs))]\n\n\ndef integral(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return integral of this polynomial in the same form.\n    >>> integral([3, 1, 2, 4, 5])\n    [0.0, 0.5, 0.333333333333333, 0.25, 0.2]\n    >>> integral([1, 2, 3])\n    [0.0, 0.5, 1.0]\n    \"\"\"\n    return [xs[i] / (i if i != 0 else 1) for i in range(len(xs))]\n\n\ndef evaluate(coeffs: list, x: float):\n    \"\"\" coeffs represent coefficients of a polynomial.\n    coeffs[0] + coeffs[1] * x + coeffs[2] * x^2 + ....\n     Return the value of this polynomial at x.\n    >>> evaluate([3, 1, 2, 4, 5], 2)\n    33\n    >>> evaluate([1, 2, 3], 2)\n    11\n    \"\"\"\n    return sum(coeffs[i] * x ** i for i in range(len(coeffs)))\n\n\ndef add(coeffs1: list, coeffs2: list):\n    \"\"\" coeffs1 and coeffs2 represent coefficients of two polynomials.\n    coeffs1[0] + coeffs1[1] * x + coeffs1[2] * x^2 + ....\n    coeffs2[0] + coeffs2[1] * x + coeffs2[2] * x^2 + ....\n     Return the coefficients of the sum of these two polynomials.\n    >>> add([3, 1, 2, 4, 5], [1, 2, 3])\n    [4, 3, 5, 4, 5]\n    >>> add([1, 2, 3], [3, 1, 2, 4, 5])\n    [4, 3, 5, 4, 5]\n    \"\"\"\n    len1, len2 = len(coeffs1), len(coeffs2)\n    max_len = max(len1, len2)\n    result = [0] * max_len\n    for i in range(max_len):\n        if i < len1:\n            result[i] += coeffs1[i]\n        if i < len2:\n            result[i] += coeffs2[i]\n    return result\n\n\ndef multiply(coeffs1: list, coeffs2: list):\n    \"\"\" coeffs1 and coeffs2 represent coefficients of two polynomials.\n    coeffs1[0] + coeffs1[1] * x + coeffs1[2] * x^2 + ....\n    coeffs2[0] + coeffs2[1] * x + coeffs2[2] * x^2 + ....\n     Return the coefficients of the product of these two polynomials.\n    >>> multiply([3, 1, 2, 4, 5], [1, 2, 3])\n    [3, 9, 18, 27, 36, 21, 10]\n    >>> multiply([1, 2, 3], [3, 1, 2, 4, 5])\n    [3, 9, 18, 27, 36, 21, 10]\n    \"\"\"\n    len"}
{"task_id": "HumanEval/70", "completion": "\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    lst.sort()\n    result = []\n    while lst:\n        result.append(lst.pop(0))\n        if lst:\n            result.append(lst.pop())\n    return result\n\n\nprint(strange_sort_list([1, 2, 3, 4]))\nprint(strangeort_list([5, 5, 5, 5]))\nprint(strange_sort_list([]))\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, 5, 5\n# []\n\n# 1, 4, 2, 3\n# 5, 5, "}
{"task_id": "HumanEval/115", "completion": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"\n    # Initialize variables\n    n, m = len(grid), len(grid[0])\n    buckets = [0] * m\n    total_water = sum(sum(row) for row in grid)\n    max_buckets = math.ceil(total_water / capacity)\n\n    # Fill buckets with water from wells\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                buckets[j] += 1\n\n    # Calculate the number of times we need to lower the buckets\n    return max_buckets - sum(buckets) // capacity\n\n\nprint(max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1))  # 6\nprint(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2))  # 5\nprint(max_fill([[0,0,0], [0,0,0]], 5))  # 0\n\n# The time complexity is O(n*m) as we are iterating through the grid.\n# The space complexity is O(m) as we are storing the buckets.\n# Here, n is the number of rows in the grid and m is the number of columns in the grid.\n# The function max_fill calculates the number of times we need to lower the buckets to empty the wells.\n# The function uses the bucket_capacity to calculate the maximum number of buckets required.\n# The function returns the difference between the maximum number of buckets required and the actual number of buckets.\n# This difference is the number of times we need to lower the buckets.\n# If the total water is less than or equal to the capacity of the buckets, the function returns 0 as no buckets are needed.\n# If the total water is greater than the capacity of the buckets, the function returns the number of times we need to lower the buckets to empty the wells.\n# The function uses the sum function to calculate the total water in the wells and the math.ceil function to calculate the maximum number of buckets required.\n# The function returns the difference between the maximum number of buckets required and the actual number of buckets.\n# This difference is the number of times we need to lower the buckets.\n# If the total water is less than or equal to the capacity of the buckets, the function returns 0 as no buckets are needed.\n# If the total water is greater than the capacity of the buckets, the function returns the number of times we need to lower the buckets to empty the wells.\n# The function uses the sum function to calculate the total water in the wells and the math.ceil function to calculate the maximum number of buck"}
{"task_id": "HumanEval/0", "completion": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i+1] - numbers[i] < threshold:\n            return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n#tests/test_has_close_elements.py\nimport unittest\nfrom has_close_elements import has_close_elements\n\nclass TestHasCloseElements(unittest.TestCase):\n\n    def test_has_close_elements(self):\n        self.assertEqual(has_close_elements([1.0, 2.0, 3.0], 0.5), False)\n        self.assertEqual(has_close_elements([1.0, 2.8, 3.0, 4.0, 5., 2.0], 0.3), True)\n\nif __name__ == '__main__':\n    unittest.main()from typing import List\n\ndef find_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" Find all duplicates in the given list of numbers.\n    >>> find_duplicates([1, 2, 2, 3, 4, 4, 5])\n    [2, 4]\n    \"\"\"\n    counts = {}\n    for num in numbers:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    duplicates = [num for num, count in counts.items() if count > 1]\n    return duplicates\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n#tests/test_find_duplicates.py\nimport unittest\nfrom find_duplicates import find_duplicates\n\nclass TestFindDuplicates(unittest.TestCase):\n\n    def test_find_duplicates(self):\n        self.assertEqual(find_duplicates([1, 2, 2, 3, 4, 4, 5]), [2, 4])\n\nif __name__ == '__main__':\n    unittest.main()from typing import List\n\ndef find_missing_numbers(numbers: List[int]) -> List[int]:\n    \"\"\" Find all missing numbers in the given list of numbers.\n    >>> find_missing_numbers([1, 2, 4, 6, 8])\n    [3, 5, 7]\n    \"\"\"\n    min_num = min(numbers)\n    max_num = max(numbers)\n    all_nums = list(range(min_num, max_num + 1))\n    missing_nums = [num for num in all_nums if num not in numbers]\n    return missing_nums\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n#tests/test_find_missing_numbers.py\nimport unittest\nfrom find_missing_numbers import find_missing_numbers\n\nclass TestFindMissingNumbers(unittest.TestCase):\n\n    def test_find_missing_numbers(self):\n        self.assertEqual(find_missing_numbers([1, 2, 4, 6, 8]), [3, 5, 7])\n\nif __name__ == '__main__':\n    unittest.main()from typing import List\n\ndef find_max_difference(numbers: List[int]) -> int:\n    \"\"\" Find the maximum difference between any two numbers in the given list of numbers.\n    >>>"}
{"task_id": "HumanEval/56", "completion": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if not stack or stack[-1] != \"<\":\n                return False\n            stack.pop()\n    return not stack\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n#tests/test_correct_bracketing.py\nimport pytest\nfrom bracket_check import correct_bracketing\n\n\n@pytest.mark.parametrize(\"brackets, expected\", [\n    (\"<\", False),\n    (\"<>\", True),\n    (\"<<><>>\", True),\n    (\"><<>\", False),\n])\ndef test_correct_bracketing(brackets, expected):\n    assert correct_bracketing(brackets) == expected#src/config.py\nimport os\n\nclass Config:\n    SECRET_KEY = os.environ.get('SECRET_KEY')\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n    MAIL_SERVER = 'smtp.googlemail.com'\n    MAIL_PORT = 587\n    MAIL_USE_TLS = True\n    MAIL_USERNAME = os.environ.get('EMAIL_USER')\n    MAIL_PASSWORD = osos.environ.get('EMAIL_PASS')\n\n#src/forms.py\nfrom flask_wtf import FlaskForm\nfrom wtforms import StringField, PasswordField, BooleanField, SubmitField, TextAreaField\nfrom wtforms.validators import ValidationError, DataRequired, Email, EqualTo\nfrom .models import User\n\nclass RegistrationForm(FlaskForm):\n    username = StringField('Username', validators=[DataRequired()])\n    email = StringField('Email', validators=[DataRequired(), Email()])\n    password = PasswordField('Password', validators=[DataRequired()])\n    password2 = PasswordField(\n        'Repeat Password', validators=[DataRequired(), EqualTo('password')])\n    submit = SubmitField('Register')\n\n    def validate_username(self, username):\n        user = User.query.filter_by(username=username.data).first()\n        if user is not None:\n            raise ValidationError('Please use a different username.')\n\n    def validate_email(self, email):\n        user = User.query.filter_by(email=email.data).first()\n        if user is not None:\n            raise ValidationError('Please use a different email address.')\n\nclass LoginForm(FlaskForm):\n    username = StringField('Username', validators=[DataRequired()])\n    password = PasswordField('Password', validators=[DataRequired()])\n    remember_me = BooleanField('Remember Me')\n    submit = SubmitField('Sign In')\n\nclass ResetPasswordRequestForm(FlaskForm):\n    email = StringField('Email', validators=[DataRequired(), Email()])\n    submit = SubmitField('Request Password Reset')\n\nclass ResetPasswordForm(FlaskForm):\n    password = PasswordField('Password', validators=[DataRequired()])\n    password2 = PasswordField(\n        'Repeat Password', validators=[DataRequired(), EqualTo('password')])\n    submit = SubmitField('Request Password Reset')\n\nclass EditProfileForm(FlaskForm):\n    username = StringField('Username', validators=[DataRequired()])\n    about_me = TextAreaField('About me', validators=[Length(min=0, max=140)])\n    submit = Submit"}
{"task_id": "HumanEval/118", "completion": "\ndef get_closest_vowel(word):\n    \"\"\"You are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels and word[i-1] not in vowels and word[i+1] not in vowels:\n            return word[i]\n    return \"\"\n\nprint(get_closest_vowel(\"yogurt\"))\nprint(get_closest_vowel(\"FULL\"))\nprint(get_closest_vowel(\"quick\"))\nprint(get_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n<jup_closest_vowel(\"ab\"))\n"}
{"task_id": "HumanEval/87", "completion": "\ndef get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n    return coordinates\n\n\nprint(get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\nprint(get_row([], 1))\nprint(get_row([[], [1], [1, 2, 3]], 3))\n\n# Output:\n# [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# []\n# [(2, 2)]\n\n# Time complexity: O(n*m)\n# Space complexity: O(n)\n# where n is the number of rows and m is the number of columns in the list.\n\n# This solution is based on the idea of iterating over the list and finding the coordinates of the given number.\n# The coordinates are then sorted as per the problem statement and returned.\n# The time complexity is O(n*m) because in the worst case scenario, we might have to go through all the elements of the list.\n# The space complexity is O(n) because in the worst case scenario, we might have to store all the coordinates of the given number in the list.\n# This solution is efficient and works well for all test cases.\n\n# Note: This solution assumes that the input list is a 2D list (matrix) and that each row in the list is a list of integers.\n# If the input list is not a 2D list or if each row in the list is not a list of integers, the solution may not work as expected.\n# Therefore, it is important to ensure that the input is valid before using this solution.\n\n# Note: This solution assumes that the input list is a 2D list (matrix) and that each row in the list is a list of integers.\n# If the input list is not a 2D list or if each row in the list is not a list of integers, the solution may not work as expected.\n# Therefore, it is important to ensure that the input is valid before using this solution.\n\n# Note: This solution assumes that the input list is a 2D list (matrix) and that each row in the list is a list of integers.\n# If the input list is not a 2D list or if each row in the list is not a list of integers, the solution may not work as expected.\n# Therefore, it is important to ensure that the input is valid before using this solution.\n\n# Note: This solution assumes that the input list is a 2D list (matrix) and that each row in the list is a list of integers.\n# If the input list is not a 2D list or if each row in the list is not a list of integers, the solution may not work as expected.\n# Therefore, it is important"}
{"task_id": "HumanEval/75", "completion": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    factors = []\n    for i in range(2, a):\n        if a % i == 0 and is_prime(i):\n            factors.append(i)\n            a //= i\n            if len(factors) > 3:\n                return False\n    return len(factors) == 3 and is_prime(a)\n\n\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(60))  # True\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(60))  # True\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(60))  # True\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(60))  # True\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(60))  # True\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(60))  # True\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(60))  # True\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(60))  # True\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(60))  # True\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(60))  # True\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(60))  # True\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(60))  # True\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(60))  # True\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(60))  # True\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(60))  # True\nprint(is_multiply_prime(30)) "}
{"task_id": "HumanEval/55", "completion": "\n\ndef fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n == 1:\n        return 1\n    elif n == 0:\n        return 0\n    else:\n        return fib(n - 1) + fib(n - 2)\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()\n\n#lab_03/task_02.py\ndef fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n == 1:\n        return 1\n    elif n == 0:1\n        return 0\n    else:\n        return fib(n - 1) + fib(n - 2)\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()\n\n#lab_03/task_03.py\ndef fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n == 1:\n        return 1\n    elif n == 0:\n        return 0\n    else:\n        return fib(n - 1) + fib(n - 2)\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()\n\n#lab_03/task_04.py\ndef fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n == 1:\n        return 1\n    elif n == 0:\n        return 0\n    else:\n        return fib(n - 1) + fib(n - 2)\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()\n\n#lab_03/task_05.py\ndef fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n == 1:\n        return 1\n    elif n == 0:\n        return 0\n    else:\n        return fib(n - 1) + fib(n - 2)\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()\n\n#lab_03/task_06.py\ndef fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n == 1:\n        return 1\n    elif n == 0:\n        return 0\n    else:\n        return fib(n - 1) + fib(n - 2)\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()\n\n#lab_03/task_07.py\ndef fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n == 1:\n        return 1\n    elif n == 0:\n        return 0"}
{"task_id": "HumanEval/52", "completion": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for i in l:\n        if i >= t:\n            return False\n    return True\n\n\ndef sum_of_digits(n: int):\n    \"\"\"Return the sum of the digits of n.\n    >>> sum_of_digits(1234)\n    10\n    >>> sum_of_digits(1000)\n    1\n    \"\"\"\n    return sum(int(i) for i in str(n))\n\n\ndef is_prime(n: int):\n    \"\"\"Return True if n is a prime number.\n    >>> is_prime(2)\n    True\n    >>> is_prime(1)\n    False\n    >>> is_prime(4)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef is_palindrome(s: str):\n    \"\"\"Return True if s is a palindrome.\n    >>> is_palindrome('radar')\n    True\n    >>> is_palindrome('python')\n    False\n    \"\"\"\n    return s == s[::-1]\n\n\ndef is_anagram(s1: str, s2: str):\n    \"\"\"Return True if s1 and s2 are anagrams.\n    >>> is_anagram('listen', 'silent')\n    True\n    >>> is_anagram('hello', 'world')\n    False\n    \"\"\"\n    return sorted(s1) == sorted(s2)\n\n\ndef is_subsequence(s1: str, s2: str):\n    \"\"\"Return True if s1 is a subsequence of s2.\n    >>> is_subsequence('abc', 'ahbgdc')\n    True\n    >>> is_subsequence('axc', 'ahbgdc')\n    False\n    \"\"\"\n    t = iter(s2)\n    return all(c in t for c in s1)\n\n\ndef is_valid_parentheses(s: str):\n    \"\"\"Return True if the string s is a valid parentheses.\n    >>> is_valid_parentheses('()')\n    True\n    >>> is_valid_parentheses('(()')\n    False\n    \"\"\"\n    stack = []\n    for c in s:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if not stack or stack.pop() != '(':\n                return False\n    return not stack\n\n\ndef is_valid_braces(s: str):\n    \"\"\"Return True if the string s is a valid braces.\n    >>> is_valid_braces('()')\n    True\n    >>> is_valid_braces('(()')\n    False\n    \"\"\"\n    stack = []\n    for c in s:\n        if c in '([{':\n            stack.append(c)\n        elif c in ')]}':\n            if not stack or stack.pop() != {'(': ')', '[': ']', '{': '}'}[c]:\n                return False\n    return not stack\n\n\ndef is_valid_IPv4(s: str):\n    \"\"\"Return True if the string s is a valid IPv4 address.\n    >>> is_valid_IPv4('192.168.1.1')\n    True\n    >>> is_valid_IPv4('192.168.1.256')\n    False\n    \"\"\"\n    parts = s.split('.')\n    if len(parts) != 4:\n        return False\n    for part in parts:\n        if not part.isdigit():\n            return False\n        i = int(part)\n        if i < 0 or i > 255:\n            return False\n    return True\n\n\ndef is_valid_IPv6(s: str):\n    \"\"\"Return True if the string s is a"}
{"task_id": "HumanEval/157", "completion": "\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n    # sort the sides\n    sides = sorted([a, b, c])\n\n    # check if the triangle is right-angled\n    return sides[0]**2 + sides[1]**2 == sides[2]**2\n\n\nprint(right_angle_triangle(3, 4, 5))  # True\nprint(right_angle_triangle(1, 2, 3))  # False\nprint(right_angle_triangle(5, 12, 13))  # True\nprint(right_angle_triangle(6, 8, 10))  # True\nprint(right_angle_triangle(7, 24, 25))  # True\nprint(right_angle_triangle(3, 6, 8))  # False\nprint(right_angle_triangle(7, 15, 20))  # False\nprint(right_angle_triangle(10, 25, 28))  # False\nprint(right_angle_triangle(12, 15, 20))  # False\nprint(right_angle_triangle(13, 16, 21))  # False\nprint(right_angle_triangle(14, 17, 22))  # False\nprint(right_angle_triangle(15, 18, 23))  # False\nprint(right_angle_triangle(16, 19, 24))  # False\nprint(right_angle_triangle(17, 20, 25))  # False\nprint(right_angle_triangle(18, 21, 26))  # False\nprint(right_angle_triangle(19, 22, 27))  # False\nprint(right_angle_triangle(20, 23, 28))  # False\nprint(right_angle_triangle(21, 24, 29))  # False\nprint(right_angle_triangle(22, 25, 30))  # False\nprint(right_angle_triangle(23, 26, 31))  # False\nprint(right_angle_triangle(24, 27, 32))  # False\nprint(right_angle_triangle(25, 28, 33))  # False\nprint(right_angle_triangle(26, 29, 34))  # False\nprint(right_angle_triangle(27, 30, 35))  # False\nprint(right_angle_triangle(28, 31, 36))  # False\nprint(right_angle_triangle(29, 32, 37))  # False\nprint(right_angle_triangle(30, 33, 38))  # False\nprint(right_angle_triangle(31, 34, 39))  # False\nprint(right_angle_triangle(32, 35, 40))  # False\nprint(right_angle_triangle(33, 36, 41))  # False\nprint(right_angle_triangle(34, 37, 42))  # False\nprint(right_angle_triangle(35, 38, 43))  # False\nprint(right_angle_triangle(36, 39, 44))  # False\nprint(right_angle_triangle(37, 40, 45))  # False\nprint(right_angle_triangle(38, 41, 46))  # False\nprint(right_angle_triangle(39, 42, 47))  # False\nprint(right_angle_triangle(40, 43, 48))  # False\nprint(right_angle_triangle(41, 4"}
{"task_id": "HumanEval/79", "completion": "\ndef decimal_to_binary(decimal):\n    \"\"\"You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n    binary = bin(decimal)[2:]\n    return f\"db{binary}db\"\n\n\nprint(decimal_to_binary(15))  # returns \"db1111db\"\nprint(decimal_to_binary(32))  # returns \"db100000db\"\n\n# 15 in binary is 1111\n# 32 in binary is 100000\n# So, the output is \"db1111db\" and \"db100000db\" respectively.\n# The 'db' are there to help with the format. They are not part of the binary number.\n# The binary number is the part of the string between the 'db'.\n# The binary number is the binary representation of the decimal number.\n# The binary representation is a string of '0's and '1's.\n# The '0's and '1's represent the binary digits of the number.\n# The binary digits are the parts of the binary number that are separated by the 'db'.\n# The 'db' are there to help with the format. They are not part of the binary number.\n# The binary number is the part of the string between the 'db'.\n# The binary number is the binary representation of the decimal number.\n# The binary representation is a string of '0's and '1's.\n# The '0's and '1's represent the binary digits of the number.\n# The binary digits are the parts of the binary number that are separated by the 'db'.\n# The 'db' are there to help with the format. They are not part of the binary number.\n# The binary number is the part of the string between the 'db'.\n# The binary number is the binary representation of the decimal number.\n# The binary representation is a string of '0's and '1's.\n# The '0's and '1's represent the binary digits of the number.\n# The binary digits are the parts of the binary number that are separated by the 'db'.\n# The 'db' are there to help with the format. They are not part of the binary number.\n# The binary number is the part of the string between the 'db'.\n# The binary number is the binary representation of the decimal number.\n# The binary representation is a string of '0's and '1's.\n# The '0's and '1's represent the binary digits of the number.\n# The binary digits are the parts of the binary number that are separated by the 'db'.\n# The 'db' are there to help with the format. They are not part of the binary number.\n# The binary number is the part of the string between the 'db'.\n# The binary number is the binary representation of the decimal number.\n# The binary representation is a string of '0's and '1's.\n# The '0's and '1's represent the binary digits of the number.\n# The binary digits are the parts of the binary number that are separated by the 'db'.\n# The 'db' are there to help with the format. They are not part of the binary number.\n# The binary number is the part of the string between the 'db'.\n# The binary number is the binary representation of the decimal number.\n# The binary representation is a string of '0's and '1's.\n# The '0's and '1's represent the binary digits of the number.\n# The binary digits are the parts of the binary number that are separated by the 'db'.\n# The 'db' are there to help with the format. They are not part of the binary number.\n# The binary number is the part of the string between the 'db'.\n# The binary number is the binary representation"}
